# Bio-Inspired Artificial Intelligence - Assignment 1
# Program: assign01.py
# Author: Alexander Jermann

# Report will be uploaded shortly

import random
import GAinspector

# returns a random genome (bit string) of a given length.
def randomGenome(length):
    x = ""
    for i in range(length):
        r = random.randint(0,1)
        x += str(r)
    return x

# returns a new randomly created population of the specified size, represented as a list of genomes of the specified length.
def makePopulation(size, length):
    population = []
    for i in range(size):
        population.append(randomGenome(length))
    return population

# returns the fitness value of a genome.
def fitness(genome):
    fitness = sum(int(x) for x in genome)
    return fitness

# returns a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
def evaluateFitness(population):
    total = 0.0
    maxFit = 0.0
    totalFit = 0.0
    for i in range(0, len(population)):
        fit = fitness(population[i])
        totalFit += fit
        if fit > maxFit:
            maxFit = fit
    avgFit = totalFit/len(population)
    return (avgFit, maxFit)

# returns two new genomes produced by crossing over the given genomes at a random crossover point.
def crossover(genome1, genome2):
    a = random.randrange(1,len(genome1))
    ngenome1 = genome1[:a] + genome2[a:]
    ngenome2 = genome2[:a] + genome1[a:]
    return (ngenome1, ngenome2)

# returns a new mutated version of the given genome.
def mutate(genome, mutationRate):
    ngenome = list(genome)
    bools = [c == '1' for c in ngenome]
    for i in range(0, len(ngenome)):
        r = random.random()
        if r < mutationRate:
            if bools[i] == True:
                ngenome[i] = '0'
            else:
                ngenome[i] = '1'
    return ''.join(ngenome)

def weightedChoice(elements, weights):
    assert len(elements) == len(weights)
    assert all([v >= 0 for v in weights])
    total = sum(weights)
    r = random.uniform(0, total)
    w = 0
    for i in range(0, len(elements)):
        w += weights[i]
        if w > r:
            return elements[i]
    return random.choice(elements)

# selects and returns two genomes from the given population using fitness-proportionate selection. This function should use weightedChoice, which we wrote in class, as a helper function.
def selectPair(population):
    fitnessList = [fitness(population[i]) for i in range(0,len(population))]
    gen1 = weightedChoice(population,fitnessList)
    gen2 = weightedChoice(population,fitnessList) #small probability of choosing the same genome twice (problem?)
    return (gen1, gen2)

# runGA is the main GA program, which takes the population size, crossover rate (pc),
# and mutation rate (pm) as parameters. The optional logFile parameter is a string
# specifying the name of a text file in which to store the data generated by the GA,
# for plotting purposes. When the GA terminates, this function should return the
# generation number at which the string of all ones was found.
def runGA(populationSize, crossoverRate, mutationRate, logFile="Dataset.txt"):
    genomeLength = 20
    population1 = makePopulation(populationSize, genomeLength)
    population2 = []
    generation = 0
    maxFit = 0

    ################################################################################################
    #### un-comment all sections below inside runGA to get terminal output and generate Dataset ####
    ################################################################################################

    #f = open(logFile, 'w')

    #print "Population Size:", populationSize
    #print "Genome length: 20"

    while maxFit < genomeLength:
        for i in range(0, populationSize/2):
            parents = selectPair(population1)
            parent1, parent2 = parents
            r = random.random()
            if r < crossoverRate:
                off1, off2 = crossover(parent1, parent2)
            else:
                off1 = parent1
                off2 = parent2
            population2.append(mutate(off1, mutationRate))
            population2.append(mutate(off2, mutationRate))
        generation += 1
        evalFit = evaluateFitness(population2)
        avgFit, maxFit = evalFit
        # if len(population1) == len(population2):
            # print "Generation %4d:   average fitness %6.2f,   best fitness %3d " % (generation, avgFit, maxFit)
            #f.write("%4d %7.2f %6.2f\n" % (generation, avgFit, maxFit))
        population1 = population2
        population2 = []
    #f.close()
    #print "dataset written to %s \n" % logFile
    return generation

# writes how many generations per run required to reach desired bitstring
def experiment1(populationSize, crossoverRate, mutationRate, tries, dataFile="03-Dataset.txt"):
    d = open(dataFile, 'w')
    for i in range(tries):
        generation = runGA(populationSize, crossoverRate, mutationRate)
        d.write("%4d %4d\n" % (i, generation))
    d.close()
    print "dataset written to %s \n" % dataFile

# returns average amount of generations needed to generate the desired bitstring
def average1(filename):
    f = open(filename, 'r')
    temp = 0.0
    b = 0.0
    for line in f.readlines():
        s1, s2 = line.split()
        temp += float(s2)
        b += 1.0
    avg = temp / b
    print "avg = %4.2f" % avg
    f.close()
